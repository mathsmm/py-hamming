Plano:

Polis e Lucas:
    Conversão de arquivo
        1) Conversão a serviço do Sender:
            *Ver material da última aula do Rodacki (página 113)!

            variável para armazenar o arquivo original
            método open do python (open(arquivo))
            transformar o arquivo para string (str(arquivo))
            bytearray para transformar o arquivo num array de bytes (utf8)
            laço para tirar o "0b" dos elementos do bytearray
            passar o array para um arquivo .txt
            método close do python (arquivo.close())

        2) Conversão a serviço do Receiver:
            variável para armazenar o arquivo.txt
            método open do python (open(arquivo))
            transformar o arquivo para string (str(arquivo)) ???
            laço para inserir o "0b" nos bytes ???
            PESQUISAR COMO TRANSFORMAR O ARRAY DE BYTES PARA UM ARQUIVO

    Gerador de ruído
        Opções de geração de ruído:
            Ruídos de bits longes (em diferentes quadros)
            Ruídos aleatórios
            Ruídos em rajada
        Opção para delimitar a quantidade de bits ruidosos!
        Guardar quais foram os bits embaralhados
            Colocar os índices deles num array
        Vai precisar da biblioteca random!

José e Matheus:
    Sender
        Codificação por Hamming
        15,4 (11 bits de dado, 4 bits de paridade de Hamming e 1 bit de paridade especial (Hamming estendido))
        A quantidade de bits, em relação à de paridade, é uma potência de 2

        Quadro 15,4 (bits)
            esp. par. par. data
            par. data data data
            par. data data data
            data data data data

        Se tiver 1 erro:
            Paridade especial somente detecta
            Paridade de Hamming detecta e também corrige

        Se tiver 2 erros:
            Paridade especial não detecta
            Paridade de Hamming somente detecta

        Quantidade par de erros:
            O bit especial NÃO detecta!

        Quantidade ímpar de erros:
            O bit especial detecta!

        Posições:
            0000 0001 0010 0011
            0100 0101 0110 0111
            1000 1001 1010 1011
            1100 1101 1110 1111

            0    1    2    3
            4    5    6    7
            8    9    10   11
            12   13   14   15

            Q1: Colunas 2 e 4
            Q2: Colunas 3 e 4
            Q3: Linhas 2 e 4
            Q4: Linhas 3 e 4

            Para ser resistente a rajadas de ruídos:
                Embaralhar os quadros de Hamming, de modo que
                se ocorrer rajada, os erros ficarão espalhados
                em diferentes quadros

    Receiver
        Fazer a verificação de cada quadro de Hamming
        Detectar se tem erro
        Se possível, corrigir o erro
        Se não for possível, marcar bloco como irrecuperável
        Informações:
            Quantidade de quadros sem ruído
            Quantidade de quadros ruidosos corrigidos
            Quantidade de quadros ruidosos irrecuperáveis

        Supondo que o bit na posição 7 (0111) esteja com erro:
                As verificações que detectam o erro gerarão um padrão
                igual à posição do bit com erro.
                Ex: Q1 Detecta!     --> 1
                    Q2 Detecta!     --> 1
                    Q3 Detecta!     --> 1
                    Q4 Não detecta! --> 0
                    Que é exatamente a posição do bit com erro! (0111)

        Ao armazenar a posição de todos os bits e aplicar XOR nelas,
        o resultado será a posição do bit defeituoso! (Considerando
        que tenha somente um bit com ruído)